#include <stdint.h>

#include "memory.h"

#ifdef TARGETWEB
#include "fake-progmen.h"
#include <emscripten/emscripten.h>
#else
#include <avr/pgmspace.h>
#endif

#include "MemIo/MemIo.h"
#include "MemIo/MemIoRam.h"
#include "MemIo/MemIoRom.h"
#include "MemIo/Riot002.h"

#include "roms/cassette.h"
#include "roms/monitor.h"
#include "roms/calcrom.h"
#include "roms/astroid.h"
#include "cpu.h"
#include "boardhardware.h"
#include "builtin_display.h"
#include "serial_display.h"
#include "kim-hardware.h"

/* MOVIT utility, copied into RAM 1780-17E3. Length: decimal 102 */
/* for use, see http://users.telenet.be/kim1-6502/6502/fbok.html#p114 */
const uint8_t movit[100] PROGMEM = {
    0xD8, 0xA0, 0xFF, 0x38, 0xA5, 0xD2, 0xE5, 0xD0,
    0x85, 0xD8, 0xA5, 0xD3, 0xE5, 0xD1, 0x85, 0xD9,
    0x18, 0xA5, 0xD8, 0x65, 0xD4, 0x85, 0xD6, 0xA5,
    0xD9, 0x65, 0xD5, 0x85, 0xD7, 0xE6, 0xD8, 0xE6,
    0xD9, 0x38, 0xA5, 0xD4, 0xE5, 0xD0, 0xA5, 0xD5,
    0xE5, 0xD1, 0xA2, 0x00, 0x90, 0x02, 0xA2, 0x02,
    0xA1, 0xD0, 0x81, 0xD4, 0x90, 0x14, 0xC6, 0xD2,
    0x98, 0x45, 0xD2, 0xD0, 0x02, 0xC6, 0xD3, 0xC6,
    0xD6, 0x98, 0x45, 0xD6, 0xD0, 0x02, 0xC6, 0xD7,
    0xB0, 0x0C, 0xE6, 0xD0, 0xD0, 0x02, 0xE6, 0xD1,
    0xE6, 0xD4, 0xD0, 0x02, 0xE6, 0xD5, 0xC6, 0xD8,
    0xD0, 0x02, 0xC6, 0xD9, 0xD0, 0xCC, 0x00};

/* RELOCATE utility, copied into RAM 0110-01A4. Length: decimal 149 */
/* for use, see http://users.telenet.be/kim1-6502/6502/fbok.html#p114 */
const uint8_t relocate[149] PROGMEM = {
    0xD8, 0xA0, 0x00, 0xB1, 0xEA, 0xA8, 0xA2, 0x07,
    0x98, 0x3D, 0x8E, 0x01, 0x5D, 0x95, 0x01, 0xF0,
    0x03, 0xCA, 0xD0, 0xF4, 0xBC, 0x9D, 0x01, 0x30,
    0x0D, 0xF0, 0x22, 0xE6, 0xEA, 0xD0, 0x02, 0xE6,
    0xEB, 0x88, 0xD0, 0xF7, 0xF0, 0xDA, 0xC8, 0x30,
    0xD9, 0xC8, 0xB1, 0xEA, 0xAA, 0xC8, 0xB1, 0xEA,
    0x20, 0x79, 0x01, 0x91, 0xEA, 0x88, 0x8A, 0x91,
    0xEA, 0xA0, 0x03, 0x10, 0xDE, 0xC8, 0xA6, 0xEA,
    0xA5, 0xEB, 0x20, 0x79, 0x01, 0x86, 0xE0, 0xA2,
    0xFF, 0xB1, 0xEA, 0x18, 0x69, 0x02, 0x30, 0x01,
    0xE8, 0x86, 0xE3, 0x18, 0x65, 0xEA, 0xAA, 0xA5,
    0xE3, 0x65, 0xEB, 0x20, 0x79, 0x01, 0xCA, 0xCA,
    0x8A, 0x38, 0xE5, 0xE0, 0x91, 0xEA, 0xC8, 0x10,
    0xB2, 0xC5, 0xE7, 0xB0, 0x11, 0xC5, 0xED, 0xD0,
    0x02, 0xE4, 0xEC, 0x90, 0x09, 0x48, 0x8A, 0x18,
    0x65, 0xE8, 0xAA, 0x68, 0x65, 0xE9, 0x60, 0x0C,
    0X1F, 0x0D, 0x87, 0X1F, 0xFF, 0x03, 0x0C, 0x19,
    0x08, 0x00, 0x10, 0x20, 0x03, 0x02, 0xFF, 0xFF,
    0x01, 0x01, 0x00, 0xFF, 0xFE};

/* BRANCH calculation utility, to be copied into RAM anywhere you want (relocatable). Length: decimal 42 */
/* for use, see http://users.telenet.be/kim1-6502/6502/fbok.htmln#p114 */
const uint8_t branch[42] PROGMEM = {
    0xD8, 0x18, 0xA5, 0xFA, 0xE5, 0xFB, 0x85, 0xF9, 0xC6, 0xF9, 0x20, 0x1F, 0x1F, 0x20, 0x6A, 0x1F,
    0xC5, 0xF3, 0xF0, 0xEC, 0x85, 0xF3, 0xC9, 0x10, 0xB0, 0xE6, 0x0A, 0x0A, 0x0A, 0x0A, 0xA2, 0x04,
    0x0A, 0x26, 0xFA, 0x26, 0xFB, 0xCA, 0xD0, 0xF8, 0xF0, 0xD6};


/* C:\temp27\KIM Uno\sw\tools\WozBaum disasm\WozBaum disasm\dis2.bin (02/09/2014 23:58:36)
   StartOffset: 00000000, EndOffset: 000001F8, Length: 000001F9 */
const uint8_t disasm[505] PROGMEM = {
    0x20, 0x0F, 0x20, 0x20, 0x9E, 0x1E, 0x20, 0x9E, 0x1E, 0x20, 0x9E, 0x1E,
    0x4C, 0x64, 0x1C, 0xA9, 0x0D, 0x85, 0x02, 0x20, 0x21, 0x20, 0x20, 0xFC,
    0x20, 0x85, 0x00, 0x84, 0x01, 0xC6, 0x02, 0xD0, 0xF2, 0x20, 0xE2, 0x20,
    0xA1, 0x00, 0xA8, 0x4A, 0x90, 0x0B, 0x4A, 0xB0, 0x17, 0xC9, 0x22, 0xF0,
    0x13, 0x29, 0x07, 0x09, 0x80, 0x4A, 0xAA, 0xBD, 0x1B, 0x21, 0xB0, 0x04,
    0x4A, 0x4A, 0x4A, 0x4A, 0x29, 0x0F, 0xD0, 0x04, 0xA0, 0x80, 0xA9, 0x00,
    0xAA, 0xBD, 0x5F, 0x21, 0x85, 0x03, 0x29, 0x03, 0x85, 0x04, 0x98, 0x29,
    0x8F, 0xAA, 0x98, 0xA0, 0x03, 0xE0, 0x8A, 0xF0, 0x0B, 0x4A, 0x90, 0x08,
    0x4A, 0x4A, 0x09, 0x20, 0x88, 0xD0, 0xFA, 0xC8, 0x88, 0xD0, 0xF2, 0x48,
    0xB1, 0x00, 0x20, 0x13, 0x21, 0xA2, 0x01, 0x20, 0xF3, 0x20, 0xC4, 0x04,
    0xC8, 0x90, 0xF1, 0xA2, 0x03, 0xC0, 0x04, 0x90, 0xF2, 0x68, 0xA8, 0xB9,
    0x79, 0x21, 0x85, 0x05, 0xB9, 0xB9, 0x21, 0x85, 0x06, 0xA9, 0x00, 0xA0,
    0x05, 0x06, 0x06, 0x26, 0x05, 0x2A, 0x88, 0xD0, 0xF8, 0x69, 0x3F, 0x20,
    0x0B, 0x21, 0xCA, 0xD0, 0xEC, 0x20, 0xF1, 0x20, 0xA2, 0x06, 0xE0, 0x03,
    0xD0, 0x12, 0xA4, 0x04, 0xF0, 0x0E, 0xA5, 0x03, 0xC9, 0xE8, 0xB1, 0x00,
    0xB0, 0x1C, 0x20, 0x13, 0x21, 0x88, 0xD0, 0xF2, 0x06, 0x03, 0x90, 0x0E,
    0xBD, 0x6C, 0x21, 0x20, 0x0B, 0x21, 0xBD, 0x72, 0x21, 0xF0, 0x03, 0x20,
    0x0B, 0x21, 0xCA, 0xD0, 0xD5, 0x60, 0x20, 0xFF, 0x20, 0xAA, 0xE8, 0xD0,
    0x01, 0xC8, 0x98, 0x20, 0x13, 0x21, 0x8A, 0x4C, 0x13, 0x21, 0x20, 0x2F,
    0x1E, 0xA5, 0x01, 0xA6, 0x00, 0x20, 0xDB, 0x20, 0xA9, 0x2D, 0x20, 0x0B,
    0x21, 0xA2, 0x03, 0xA9, 0x20, 0x20, 0x0B, 0x21, 0xCA, 0xD0, 0xF8, 0x60,
    0xA5, 0x04, 0x38, 0xA4, 0x01, 0xAA, 0x10, 0x01, 0x88, 0x65, 0x00, 0x90,
    0x01, 0xC8, 0x60, 0x84, 0x07, 0x20, 0xA0, 0x1E, 0xA4, 0x07, 0x60, 0x84,
    0x07, 0x20, 0x3B, 0x1E, 0xA4, 0x07, 0x60, 0x40, 0x02, 0x45, 0x03, 0xD0,
    0x08, 0x40, 0x09, 0x30, 0x22, 0x45, 0x33, 0xD0, 0x08, 0x40, 0x09, 0x40,
    0x02, 0x45, 0x33, 0xD0, 0x08, 0x40, 0x09, 0x40, 0x02, 0x45, 0xB3, 0xD0,
    0x08, 0x40, 0x09, 0x00, 0x22, 0x44, 0x33, 0xD0, 0x8C, 0x44, 0x00, 0x11,
    0x22, 0x44, 0x33, 0xD0, 0x8C, 0x44, 0x9A, 0x10, 0x22, 0x44, 0x33, 0xD0,
    0x08, 0x40, 0x09, 0x10, 0x22, 0x44, 0x33, 0xD0, 0x08, 0x40, 0x09, 0x62,
    0x13, 0x78, 0xA9, 0x00, 0x21, 0x01, 0x02, 0x00, 0x80, 0x59, 0x4D, 0x11,
    0x12, 0x06, 0x4A, 0x05, 0x1D, 0x2C, 0x29, 0x2C, 0x23, 0x28, 0x41, 0x59,
    0x00, 0x58, 0x00, 0x00, 0x00, 0x1C, 0x8A, 0x1C, 0x23, 0x5D, 0x8B, 0x1B,
    0xA1, 0x9D, 0x8A, 0x1D, 0x23, 0x9D, 0x8B, 0x1D, 0xA1, 0x00, 0x29, 0x19,
    0xAE, 0x69, 0xA8, 0x19, 0x23, 0x24, 0x53, 0x1B, 0x23, 0x24, 0x53, 0x19,
    0xA1, 0x00, 0x1A, 0x5B, 0x5B, 0xA5, 0x69, 0x24, 0x24, 0xAE, 0xAE, 0xA8,
    0xAD, 0x29, 0x00, 0x7C, 0x00, 0x15, 0x9C, 0x6D, 0x9C, 0xA5, 0x69, 0x29,
    0x53, 0x84, 0x13, 0x34, 0x11, 0xA5, 0x69, 0x23, 0xA0, 0xD8, 0x62, 0x5A,
    0x48, 0x26, 0x62, 0x94, 0x88, 0x54, 0x44, 0xC8, 0x54, 0x68, 0x44, 0xE8,
    0x94, 0x00, 0xB4, 0x08, 0x84, 0x74, 0xB4, 0x28, 0x6E, 0x74, 0xF4, 0xCC,
    0x4A, 0x72, 0xF2, 0xA4, 0x8A, 0x00, 0xAA, 0xA2, 0xA2, 0x74, 0x74, 0x74,
    0x72, 0x44, 0x68, 0xB2, 0x32, 0xB2, 0x00, 0x22, 0x00, 0x1A, 0x1A, 0x26,
    0x26, 0x72, 0x72, 0x88, 0xC8, 0xC4, 0xCA, 0x26, 0x48, 0x44, 0x44, 0xA2,
    0xC8};

const uint8_t mchess[1393] PROGMEM = {
    0xA9, 0x00, 0x85, 0xB7, 0x20, 0x54, 0xC4, 0xD8, 0xA2, 0xFF, 0x9A, 0xA2,
    0xC8, 0x86, 0xB2, 0x20, 0x78, 0xC3, 0x20, 0x49, 0xC4, 0xC9, 0x43, 0xD0,
    0x12, 0xA2, 0x1F, 0xBD, 0x14, 0xC5, 0x95, 0x50, 0xCA, 0x10, 0xF8, 0xA2,
    0x1B, 0x86, 0xDC, 0xA9, 0xCC, 0xD0, 0x19, 0xC9, 0x45, 0xD0, 0x0E, 0x20,
    0xC1, 0xC1, 0x38, 0xA9, 0x01, 0xE5, 0xB7, 0x85, 0xB7, 0xA9, 0xEE, 0xD0,
    0x07, 0xC9, 0x40, 0xD0, 0x0B, 0x20, 0xB5, 0xC2, 0x85, 0xFB, 0x85, 0xFA,
    0x85, 0xF9, 0xD0, 0xBB, 0xC9, 0x0D, 0xD0, 0x06, 0x20, 0x5B, 0xC2, 0x4C,
    0xFD, 0xC0, 0xC9, 0x41, 0xF0, 0x03, 0x4C, 0xF6, 0xC0, 0x4C, 0x00, 0xFF,
    0xA6, 0xB5, 0x30, 0x5C, 0xA5, 0xB0, 0xF0, 0x08, 0xE0, 0x08, 0xD0, 0x04,
    0xC5, 0xE6, 0xF0, 0x2E, 0xF6, 0xE3, 0xC9, 0x01, 0xD0, 0x02, 0xF6, 0xE3,
    0x50, 0x1E, 0xA0, 0x0F, 0xA5, 0xB1, 0xD9, 0x60, 0x00, 0xF0, 0x03, 0x88,
    0x10, 0xF8, 0xB9, 0x45, 0xC5, 0xD5, 0xE4, 0x90, 0x04, 0x94, 0xE6, 0x95,
    0xE4, 0x18, 0x08, 0x75, 0xE5, 0x95, 0xE5, 0x28, 0xE0, 0x04, 0xF0, 0x03,
    0x30, 0x31, 0x60, 0xA5, 0xE8, 0x85, 0xDD, 0xA9, 0x00, 0x85, 0xB5, 0x20,
    0x5B, 0xC2, 0x20, 0xC1, 0xC1, 0x20, 0x0F, 0xC1, 0x20, 0xC1, 0xC1, 0xA9,
    0x08, 0x85, 0xB5, 0x20, 0x18, 0xC1, 0x20, 0x41, 0xC2, 0x4C, 0x12, 0xC3,
    0xE0, 0xF9, 0xD0, 0x0B, 0xA5, 0x60, 0xC5, 0xB1, 0xD0, 0x04, 0xA9, 0x00,
    0x85, 0xB4, 0x60, 0x50, 0xFD, 0xA0, 0x07, 0xA5, 0xB1, 0xD9, 0x60, 0x00,
    0xF0, 0x05, 0x88, 0xF0, 0xF1, 0x10, 0xF6, 0xB9, 0x45, 0xC5, 0xD5, 0xE2,
    0x90, 0x02, 0x95, 0xE2, 0xC6, 0xB5, 0xA9, 0xFB, 0xC5, 0xB5, 0xF0, 0x03,
    0x20, 0x35, 0xC2, 0xE6, 0xB5, 0x60, 0xC9, 0x08, 0xB0, 0x12, 0x20, 0x02,
    0xC3, 0xA2, 0x1F, 0xB5, 0x50, 0xC5, 0xFA, 0xF0, 0x03, 0xCA, 0x10, 0xF7,
    0x86, 0xFB, 0x86, 0xB0, 0x4C, 0x07, 0xC0, 0xA2, 0x10, 0xA9, 0x00, 0x95,
    0xDE, 0xCA, 0x10, 0xFB, 0xA9, 0x10, 0x85, 0xB0, 0xC6, 0xB0, 0x10, 0x01,
    0x60, 0x20, 0x2E, 0xC2, 0xA4, 0xB0, 0xA2, 0x08, 0x86, 0xB6, 0xC0, 0x08,
    0x10, 0x41, 0xC0, 0x06, 0x10, 0x2E, 0xC0, 0x04, 0x10, 0x1F, 0xC0, 0x01,
    0xF0, 0x09, 0x10, 0x0E, 0x20, 0x9D, 0xC1, 0xD0, 0xFB, 0xF0, 0xD9, 0x20,
    0xAB, 0xC1, 0xD0, 0xFB, 0xF0, 0xD2, 0xA2, 0x04, 0x86, 0xB6, 0x20, 0xAB,
    0xC1, 0xD0, 0xFB, 0xF0, 0xC7, 0x20, 0xAB, 0xC1, 0xA5, 0xB6, 0xC9, 0x04,
    0xD0, 0xF7, 0xF0, 0xBC, 0xA2, 0x10, 0x86, 0xB6, 0x20, 0x9D, 0xC1, 0xA5,
    0xB6, 0xC9, 0x08, 0xD0, 0xF7, 0xF0, 0xAD, 0xA2, 0x06, 0x86, 0xB6, 0x20,
    0xD9, 0xC1, 0x50, 0x05, 0x30, 0x03, 0x20, 0x60, 0xC0, 0x20, 0x2E, 0xC2,
    0xC6, 0xB6, 0xA5, 0xB6, 0xC9, 0x05, 0xF0, 0xEB, 0x20, 0xD9, 0xC1, 0x70,
    0x8F, 0x30, 0x8D, 0x20, 0x60, 0xC0, 0xA5, 0xB1, 0x29, 0xF0, 0xC9, 0x20,
    0xF0, 0xEE, 0x4C, 0x1C, 0xC1, 0x20, 0xD9, 0xC1, 0x30, 0x03, 0x20, 0x60,
    0xC0, 0x20, 0x2E, 0xC2, 0xC6, 0xB6, 0x60, 0x20, 0xD9, 0xC1, 0x90, 0x02,
    0x50, 0xF9, 0x30, 0x07, 0x08, 0x20, 0x60, 0xC0, 0x28, 0x50, 0xF0, 0x20,
    0x2E, 0xC2, 0xC6, 0xB6, 0x60, 0xA2, 0x0F, 0x38, 0xB4, 0x60, 0xA9, 0x77,
    0xF5, 0x50, 0x95, 0x60, 0x94, 0x50, 0x38, 0xA9, 0x77, 0xF5, 0x50, 0x95,
    0x50, 0xCA, 0x10, 0xEB, 0x60, 0xA5, 0xB1, 0xA6, 0xB6, 0x18, 0x7D, 0x34,
    0xC5, 0x85, 0xB1, 0x29, 0x88, 0xD0, 0x42, 0xA5, 0xB1, 0xA2, 0x20, 0xCA,
    0x30, 0x0E, 0xD5, 0x50, 0xD0, 0xF9, 0xE0, 0x10, 0x30, 0x33, 0xA9, 0x7F,
    0x69, 0x01, 0x70, 0x01, 0xB8, 0xA5, 0xB5, 0x30, 0x24, 0xC9, 0x08, 0x10,
    0x20, 0x48, 0x08, 0xA9, 0xF9, 0x85, 0xB5, 0x85, 0xB4, 0x20, 0x5B, 0xC2,
    0x20, 0xC1, 0xC1, 0x20, 0x18, 0xC1, 0x20, 0x3E, 0xC2, 0x28, 0x68, 0x85,
    0xB5, 0xA5, 0xB4, 0x30, 0x04, 0x38, 0xA9, 0xFF, 0x60, 0x18, 0xA9, 0x00,
    0x60, 0xA9, 0xFF, 0x18, 0xB8, 0x60, 0xA6, 0xB0, 0xB5, 0x50, 0x85, 0xB1,
    0x60, 0x20, 0x5B, 0xC2, 0x20, 0xC1, 0xC1, 0x20, 0x18, 0xC1, 0x20, 0xC1,
    0xC1, 0xBA, 0x86, 0xB3, 0xA6, 0xB2, 0x9A, 0x68, 0x85, 0xB6, 0x68, 0x85,
    0xB0, 0xAA, 0x68, 0x95, 0x50, 0x68, 0xAA, 0x68, 0x85, 0xB1, 0x95, 0x50,
    0x4C, 0x80, 0xC2, 0xBA, 0x86, 0xB3, 0xA6, 0xB2, 0x9A, 0xA5, 0xB1, 0x48,
    0xA8, 0xA2, 0x1F, 0xD5, 0x50, 0xF0, 0x03, 0xCA, 0x10, 0xF9, 0xA9, 0xCC,
    0x95, 0x50, 0x8A, 0x48, 0xA6, 0xB0, 0xB5, 0x50, 0x94, 0x50, 0x48, 0x8A,
    0x48, 0xA5, 0xB6, 0x48, 0xBA, 0x86, 0xB2, 0xA6, 0xB3, 0x9A, 0x60, 0xA6,
    0xE4, 0xEC, 0x45, 0xC5, 0xD0, 0x04, 0xA9, 0x00, 0xF0, 0x0A, 0xA6, 0xE3,
    0xD0, 0x06, 0xA6, 0xEE, 0xD0, 0x02, 0xA9, 0xFF, 0xA2, 0x04, 0x86, 0xB5,
    0xC5, 0xFA, 0x90, 0x0C, 0xF0, 0x0A, 0x85, 0xFA, 0xA5, 0xB0, 0x85, 0xFB,
    0xA5, 0xB1, 0x85, 0xF9, 0xA9, 0x2E, 0x4C, 0x60, 0xC4, 0xA6, 0xDC, 0x30,
    0x1C, 0xA5, 0xF9, 0xDD, 0x55, 0xC5, 0xD0, 0x11, 0xCA, 0xBD, 0x55, 0xC5,
    0x85, 0xFB, 0xCA, 0xBD, 0x55, 0xC5, 0x85, 0xF9, 0xCA, 0x86, 0xDC, 0xD0,
    0x1C, 0xA9, 0xFF, 0x85, 0xDC, 0xA2, 0x0C, 0x86, 0xB5, 0x86, 0xFA, 0xA2,
    0x14, 0x20, 0x11, 0xC1, 0xA2, 0x04, 0x86, 0xB5, 0x20, 0x0F, 0xC1, 0xA6,
    0xFA, 0xE0, 0x0F, 0x90, 0x12, 0xA6, 0xFB, 0xB5, 0x50, 0x85, 0xFA, 0x86,
    0xB0, 0xA5, 0xF9, 0x85, 0xB1, 0x20, 0x5B, 0xC2, 0x4C, 0x07, 0xC0, 0xA9,
    0xFF, 0x60, 0xA2, 0x04, 0x06, 0xF9, 0x26, 0xFA, 0xCA, 0xD0, 0xF9, 0x05,
    0xF9, 0x85, 0xF9, 0x85, 0xB1, 0x60, 0x18, 0xA9, 0x80, 0x65, 0xEB, 0x65,
    0xEC, 0x65, 0xED, 0x65, 0xE1, 0x65, 0xDF, 0x38, 0xE5, 0xF0, 0xE5, 0xF1,
    0xE5, 0xE2, 0xE5, 0xE0, 0xE5, 0xDE, 0xE5, 0xEF, 0xE5, 0xE3, 0xB0, 0x02,
    0xA9, 0x00, 0x4A, 0x18, 0x69, 0x40, 0x65, 0xEC, 0x65, 0xED, 0x38, 0xE5,
    0xE4, 0x4A, 0x18, 0x69, 0x90, 0x65, 0xDD, 0x65, 0xDD, 0x65, 0xDD, 0x65,
    0xDD, 0x65, 0xE1, 0x38, 0xE5, 0xE4, 0xE5, 0xE4, 0xE5, 0xE5, 0xE5, 0xE5,
    0xE5, 0xE0, 0xA6, 0xB1, 0xE0, 0x33, 0xF0, 0x16, 0xE0, 0x34, 0xF0, 0x12,
    0xE0, 0x22, 0xF0, 0x0E, 0xE0, 0x25, 0xF0, 0x0A, 0xA6, 0xB0, 0xF0, 0x09,
    0xB4, 0x50, 0xC0, 0x10, 0x10, 0x03, 0x18, 0x69, 0x02, 0x4C, 0x87, 0xC2,
    0x20, 0x17, 0xC4, 0x20, 0x3B, 0xC4, 0x20, 0x22, 0xC4, 0xA0, 0x00, 0x20,
    0xE9, 0xC3, 0xA9, 0x7C, 0x20, 0x60, 0xC4, 0xA2, 0x1F, 0x98, 0xD5, 0x50,
    0xF0, 0x40, 0xCA, 0x10, 0xF8, 0x98, 0x29, 0x01, 0x85, 0xFC, 0x98, 0x4A,
    0x4A, 0x4A, 0x4A, 0x29, 0x01, 0x18, 0x65, 0xFC, 0x29, 0x01, 0xF0, 0x03,
    0xA9, 0x2A, 0x2C, 0xA9, 0x20, 0x20, 0x60, 0xC4, 0x20, 0x60, 0xC4, 0xC8,
    0x98, 0x29, 0x08, 0xF0, 0xCD, 0xA9, 0x7C, 0x20, 0x60, 0xC4, 0x20, 0x34,
    0xC4, 0x20, 0x17, 0xC4, 0x20, 0xE9, 0xC3, 0x18, 0x98, 0x69, 0x08, 0xA8,
    0xC0, 0x80, 0xF0, 0x2B, 0xD0, 0xB4, 0xA5, 0xB7, 0xF0, 0x05, 0xBD, 0xD3,
    0xC4, 0xD0, 0x03, 0xBD, 0xC3, 0xC4, 0x20, 0x60, 0xC4, 0xBD, 0xF3, 0xC4,
    0x20, 0x60, 0xC4, 0xD0, 0xCA, 0x8A, 0x48, 0xA2, 0x19, 0xA9, 0x2D, 0x20,
    0x60, 0xC4, 0xCA, 0xD0, 0xFA, 0x68, 0xAA, 0x20, 0x17, 0xC4, 0x60, 0x20,
    0x22, 0xC4, 0xA5, 0xFB, 0x20, 0x64, 0xC4, 0xA9, 0x20, 0x20, 0x60, 0xC4,
    0xA5, 0xFA, 0x20, 0x64, 0xC4, 0xA9, 0x20, 0x20, 0x60, 0xC4, 0xA5, 0xF9,
    0x20, 0x64, 0xC4, 0xA9, 0x0D, 0x20, 0x60, 0xC4, 0xA9, 0x0A, 0x20, 0x60,
    0xC4, 0x60, 0xA2, 0x00, 0xA9, 0x20, 0x20, 0x60, 0xC4, 0x8A, 0x20, 0x64,
    0xC4, 0xE8, 0xE0, 0x08, 0xD0, 0xF2, 0xF0, 0xE3, 0x98, 0x29, 0x70, 0x20,
    0x64, 0xC4, 0x60, 0xA2, 0x00, 0xBD, 0x8A, 0xC4, 0xF0, 0x06, 0x20, 0x60,
    0xC4, 0xE8, 0xD0, 0xF5, 0x60, 0xA9, 0x3F, 0x20, 0x60, 0xC4, 0x20, 0x55,
    0xC4, 0x29, 0x4F, 0x60, 0x60, 0xAD, 0xF3, 0xCF, 0xC5, 0x01, 0xF0, 0xF9,
    0xAD, 0xF4, 0xCF, 0x60, 0x8D, 0xF1, 0xCF, 0x60, 0x48, 0x4A, 0x4A, 0x4A,
    0x4A, 0x20, 0x6D, 0xC4, 0x68, 0x29, 0x0F, 0x84, 0xFF, 0xA8, 0xB9, 0x7A,
    0xC4, 0xA4, 0xFF, 0x4C, 0x60, 0xC4, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x4D, 0x69,
    0x63, 0x72, 0x6F, 0x43, 0x68, 0x65, 0x73, 0x73, 0x20, 0x28, 0x63, 0x29,
    0x20, 0x31, 0x39, 0x39, 0x36, 0x2D, 0x32, 0x30, 0x30, 0x35, 0x20, 0x50,
    0x65, 0x74, 0x65, 0x72, 0x20, 0x4A, 0x65, 0x6E, 0x6E, 0x69, 0x6E, 0x67,
    0x73, 0x2C, 0x20, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x65, 0x6E, 0x6C, 0x6F,
    0x2E, 0x63, 0x6F, 0x6D, 0x0D, 0x0A, 0x00, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
    0x42, 0x42, 0x42, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x4B, 0x51, 0x52, 0x52, 0x42,
    0x42, 0x4E, 0x4E, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x4B,
    0x51, 0x52, 0x52, 0x42, 0x42, 0x4E, 0x4E, 0x50, 0x50, 0x50, 0x50, 0x50,
    0x50, 0x50, 0x50, 0x00, 0x03, 0x04, 0x00, 0x07, 0x02, 0x05, 0x01, 0x06,
    0x10, 0x17, 0x11, 0x16, 0x12, 0x15, 0x14, 0x13, 0x73, 0x74, 0x70, 0x77,
    0x72, 0x75, 0x71, 0x76, 0x60, 0x67, 0x61, 0x66, 0x62, 0x65, 0x64, 0x63,
    0x00, 0xF0, 0xFF, 0x01, 0x10, 0x11, 0x0F, 0xEF, 0xF1, 0xDF, 0xE1, 0xEE,
    0xF2, 0x12, 0x0E, 0x1F, 0x21, 0x0B, 0x0A, 0x06, 0x06, 0x04, 0x04, 0x04,
    0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x99, 0x25, 0x0B,
    0x25, 0x01, 0x00, 0x33, 0x25, 0x07, 0x36, 0x34, 0x0D, 0x34, 0x34, 0x0E,
    0x52, 0x25, 0x0D, 0x45, 0x35, 0x04, 0x55, 0x22, 0x06, 0x43, 0x33, 0x0F,
    0xCC};

#ifdef USE_EPROM
extern uint8_t eepromread(uint16_t eepromaddress);
extern void eepromwrite(uint16_t eepromaddress, uint8_t bytevalue);
#endif

extern char threeHex[3][2]; // buffer for 3 hex digits
extern int blitzMode;       // status variable only for microchess

// --- OVERVIEW OF KIM-1 MEMORY MAP -------------------------------------------------
uint8_t RAM[ONBOARD_RAM]; // main 1KB RAM	     0x0000-0x04FF
// empty            					    0x0900-0x13FF
// I/O and timer of 6530-003, free for user  0x1700-0x173F, not used in KIM ROM
// I/O and timer of 6530-002, used by KIM    0x1740-0x177F, used by LED/Keyboard
uint8_t RAM003[64]; // RAM from 6530-003  0x1780-0x17BF, free for user applications
uint8_t RAM002[64]; // RAM from 6530-002  0x17C0-0x17FF, free for user except 0x17E7-0x17FF
// rom003 is                                 0x1800-0x1BFF
// rom002 is                                 0x1C00-0x1FFF

// note that above 8K map is not replicated 8 times to fill 64K,
// but INSTEAD, emulator mirrors last 6 bytes of ROM 002 to FFFB-FFFF:
//               FFFA, FFFB - NMI Vector
//               FFFC, FFFD - RST Vector
//               FFFE, FFFF - IRQ Vector
// Application roms (mchess) are above standard 8K of KIM-1

// --- ROM CODE SECTION ------------------------------------------------------------
// ROM1: KIM-1 ROM002 (monitor main code)                                 $17C0
// ROM2: KIM-1 ROM003 (tape and RS-232 code)                              $1780
// mchess: the updated microchess version from www.benlo.com/microchess
//                                                 recompiled to start at $C000
// calc: the 6502 floating point library from www.crbond.com/calc65.htm
//                                                 recompiled to start at $D000
// disassembler: the famous Baum & Wozniak disassember
//    6502.org/documents/publications/6502notes/6502_user_notes_14.pdf at $2000
// storage arrays that are copied to RAM are also here:
// relocate (first book of kim)                                        to $0110
// branch (first book of kim)                                          to $01A5
// movit (first book of kim)                                           to $1780
// ---------------------------------------------------------------------------------

MemIo *memio = new MemIo();
MemIoRom *rom1 = new MemIoRom();
MemIoRom *rom2 = new MemIoRom();
MemIoRiot002 *riotIo002 = new MemIoRiot002();
MemIoRam *ramMain = new MemIoRam();
MemIoRam *ramRiot002 = new MemIoRam();
MemIoRam *ramRiot003 = new MemIoRam();

// this is what user has to enter manually when powering KIM on. Why not do it here.
void initKIM()
{
    rom1->install(0x1800, 0x1BFF, cassette);
    rom2->install(0x1C00, 0x1FFF, monitor);
    ramMain->install(0x0000, ONBOARD_RAM, RAM);
    ramRiot003->install(0x1780, 0x17BF, RAM003);
    ramRiot002->install(0x17C0, 0x17FF, RAM002);

    uint16_t i;

    write6502(0x17FA, 0x00);
    write6502(0x17FB, 0x1C);
    write6502(0x17FE, 0x00);
    write6502(0x17FF, 0x1C);

    // the code below copies movit (a copy routine) to 0x1780 in RAM. It can be
    // overwritten by users - it's an extra note that the HTML version of the
    // book contains OR scan codes, so don't take the bytes from there!

    for (i = 0; i < 64; i++)
    { //64 of 102 program bytes
        //NOCOPY   RAM003[i] = pgm_read_byte_near(movit + i);
    }

    // movit spans into the second 64 byte memory segment...

    for (i = 0; i < (95 - 64); i++)
    {
        //NOCOPY  RAM002[i] = pgm_read_byte_near(movit + i + 64);
    }

    // the code below copies relocate to 0x0110 in RAM. It can be overwritten
    // by users or by the stack pointer - it's an extra

    for (i = 0; i < 149; i++)
    {
        //NOCOPY  RAM[i + 0x0110] = pgm_read_byte_near(relocate + i);
    }

    // the code below copies branch to 0x01A5 (not 0x17C0 anymore) in RAM. It
    // can be overwritten by users - it's an extra note: the program can easily
    // be damaged by the stack, because it ends at 1CF. Still, the monitor
    // brings the stack down to no worse than 0x1FF-8.

    for (i = 0; i < 42; i++)
    {
        //RAM002[i] = pgm_read_byte_near(branch + i);
        //NOCOPY  RAM[i + 0x01A5] = pgm_read_byte_near(branch + i);
    }
}

void loadTestProgram() // Call this from main() if you want a program preloaded. It's the first program from First Book of KIM...
{
    uint16_t i;

    // the first program from First Book of KIM...

    uint8_t fbkDemo[9] = {
        0xA5, 0x10, 0xA6, 0x11, 0x85, 0x11, 0x86, 0x10, 0x00};
    write6502(0x0010, 0x10);
    write6502(0x0011, 0x11);

    //uint8_t fbkDemo[13] = {
    //    0xa9, 0xff, 0x8d, 0x40, 0x17, 0xa9, 0x09, 0x8d, 0x42, 0x17, 0x4c, 0x0a, 0x02};

    // #define fbkDemo astroid
    size_t l = sizeof fbkDemo / sizeof fbkDemo[0];

    for (i = 0; i < l; i++)
    {
        write6502(i + 0x0200, fbkDemo[i]);
    }

    // load fltpt65 demo program
    uint8_t fltptDemo[31] = {
        0x20, 0xA1, 0x70, 0x20, 0xA2, 0x70, 0xA9, 0x02, 0x20, 0x00, 0x50, 0x20, 0xD3, 0x70,
        0x20, 0xAA, 0x70,
        0xF0, 0x08,
        0x20, 0x31, 0x70, 0xA9, 0x04, 0x20, 0x00, 0x50, 0x20, 0xD3, 0x70, 0x00};
    for (i = 0x0; i < 31; i++)
    {
        // NOCOPY RAM[i + 0x0210] = fltptDemo[i];
    }

    /* org=$0210
    JSR $6FF1
    JSR $6FF2

    LDA #$02
    JSR $5000
    JSR $6FE3
    JSR $6FC1
    LDA #$04

    JSR $5000

    JSR $6FE3
    BRK    */

    /*	uint8_t helloworld[0x28] = { // test program for Serial, prints hello world
    		0xAE, 0x13, 0x02, 0xCA, 0x8E, 0x13, 0x02, 0xBD,
    		0x14, 0x02, 0x20, 0xA0, 0x1E, 0xEC, 0x00, 0x00,
    		0xD0, 0xEE, 0x00, 0x13, 0x0D, 0x0A, 0x0D, 0x0A,
    		0x64, 0x6C,
    		0x72, 0x6F, 0x77, 0x20, 0x2C, 0x6F, 0x6C, 0x6C, 0x65, 0x48,
    		0x0D, 0x0A, 0x0D, 0x0A };

    	for (int iii=0x0200; iii<0x0224;iii++)
    		RAM[iii]=helloworld[iii-0x0200];
    */
}


uint8_t read6502(uint16_t address)
{
    uint8_t tempval = 0;

    if (ramMain->inRange(address))
    {
        return ramMain->read(address);
    }

#ifdef USE_EPROM
    if (address < 0x0800)
    {
        return (eepromread(address - 0x0400)); // 0x0400-0x0800 is EEPROM for Arduino,
    }                                          // 0x0800-0x1700 is empty space, should not be read
#endif

    if (riotIo002->inRange(address))
    {
        return riotIo002->read(address);
    }

    if (ramRiot003->inRange(address))
    {
        return ramRiot003->read(address);
    }

    if (ramRiot002->inRange(address))
    {
        return ramRiot002->read(address);
    }

    if (address < 0x2000)
    { // 0x1C00-0x2000 is ROM 002. It needs some intercepting from emulator...
        if (address == 0x1EA0)
        {                  // intercept OUTCH (send char to serial)
            serout(a);     // print A to serial
            pc = 0x1ED3;   // skip subroutine
            return (0xEA); // and return from subroutine with a fake NOP instruction
        }

        if (address == 0x1E65)
        {                  //intercept GETCH (get char from serial). used to be 0x1E5A, but intercept *within* routine just before get1 test
            a = getAkey(); // get A from main loop's curkey

            if (a == 0)
            {
                pc = 0x1E60; // cycle through GET1 loop for character start, let the 6502 runs through this loop in a fake way
                return (0xEA);
            }

            clearkey();
            x = read6502(0x00FD); // x is saved in TMPX by getch routine, we need to get it back in x;
            pc = 0x1E87;          // skip subroutine
            return (0xEA);        // and return from subroutine with a fake NOP instruction
        }

        if (address == 0x1C2A)
        {                                // intercept DETCPS
            RAM002[0x17F3 - 0x17C0] = 1; // just store some random bps delay on TTY in CNTH30
            RAM002[0x17F2 - 0x17C0] = 1; // just store some random bps delay on TTY in CNTL30
            pc = 0x1C4F;                 // skip subroutine
            return (0xEA);               // and return from subroutine with a fake NOP instruction
        }

        if (address == 0x1F1F)
        { // intercept SCANDS (display F9,FA,FB)
            // light LEDs ---------------------------------------------------------
            if (
                threeHex[0][0] != (read6502(0x00FB) & 0xF0) >> 4 ||
                threeHex[0][1] != (read6502(0x00FB) & 0xF) ||
                threeHex[1][0] != (read6502(0x00FA) & 0xF0) >> 4 ||
                threeHex[1][1] != (read6502(0x00FA) & 0xF) ||
                threeHex[2][0] != (read6502(0x00F9) & 0xF0) >> 4 ||
                threeHex[2][1] != (read6502(0x00F9) & 0xF))
            {

                threeHex[0][0] = (read6502(0x00FB) & 0xF0) >> 4;
                threeHex[0][1] = read6502(0x00FB) & 0xF;
                threeHex[1][0] = (read6502(0x00FA) & 0xF0) >> 4;
                threeHex[1][1] = read6502(0x00FA) & 0xF;
                threeHex[2][0] = (read6502(0x00F9) & 0xF0) >> 4;
                threeHex[2][1] = read6502(0x00F9) & 0xF;
            }
            serial_scands();
            // driveLEDs();

            //pc = 0x1F45;   // skip subroutine part that deals with LEDs
            //return (0xEA); // and return a fake NOP instruction for this first read in the subroutine, it'll now go to AK
        }

#ifdef EMULATE_KEYBOARD
        if (address == 0x1EFE)
        {                  // intercept AK (check for any key pressed)
            a = getAkey(); // 0 means no key pressed - the important bit - but if a key is pressed is curkey the right value to send back?
            //a= getKIMkey();
            if (a == 0)
                a = 0xFF; // that's how AK wants to see 'no key'
            pc = 0x1F14;  // skip subroutine

            return (0xEA); // and return a fake NOP instruction for this first read in the subroutine, it'll now RTS at its end
        }
#endif

#ifdef EMULATE_KEYBOARD
        if (address == 0x1F6A)
        { // intercept GETKEY (get key from keyboard)
            //		serout('-');serout('G');serout('K');serout('-');
            a = getKIMkey(); // curkey = the key code in the emulator's keyboard buffer
            clearkey();
            pc = 0x1F90;   // skip subroutine part that deals with LEDs
            return (0xEA); // and return a fake NOP instruction for this first read in the subroutine, it'll now RTS at its end
        }
#endif
    }

    if (rom1->inRange(address))
    {
        return rom1->read(address);
    }

    if (rom2->inRange(address))
    {
        return rom2->read(address);
    }

    if (address < 0x21F9)
    { // 0x2000-0x21F8 is disasm
        return (pgm_read_byte_near(disasm + address - 0x2000));
    }

    if (address == 0x6666)
    {
        uint16_t p1 = 0x5000;
        uint16_t p2 = (sizeof calcRom / sizeof calcRom[0]) + p1;

        uint16_t offset = *calcRom + address - 0x5000;

        // printf("%04x %04x %04x %04x\n", offset, address, p1, p2);
    }

    if ((address >= 0x5000) && (address <= (sizeof calcRom / sizeof calcRom[0]) + 0x5000))
    {
        // 0x6FDF, plus 4 bytes for JSR manually added -
        // Read to floating point library between $5000 and $6157

        return (pgm_read_byte_near(calcRom + address - 0x5000));
    }

    if (address >= 0xC000 && address <= 0xC571)
    {                           // Read to Microchess ROM between $C000 and $C571
        if (address == 0xC202)  // intercept C202: Blitz mode should return 0 instead of 8
            if (blitzMode == 1) // This is the Blitz mode hack from the microchess manual.
                return ((uint8_t)0x00);

        return (pgm_read_byte_near(mchess + address - 0xC000)); // mchess ROM
    }

    // I/O functions just for Microchess: ---------------------------------------------------
    // $F003: 0 = no key pressed, 1 key pressed
    // $F004: input from user
    // (also, in write6502: $F001: output character to display)
    if (address == 0xCFF4)
    { //simulated keyboard input
        tempval = getAkey();
        clearkey();
        // translate KIM-1 button codes into ASCII code expected by this version of Microchess
        switch (tempval)
        {
        case 16:
            tempval = 'P';
            break; // PC translated to P
        case 'F':
            tempval = 13;
            break; // F translated to Return
        case '+':
            tempval = 'W';
            break; // + translated to W meaning Blitz mode toggle
        }
        if (tempval == 0x57)
        { // 'W'. If user presses 'W', he wants to enable Blitz mode.
            if (blitzMode == 1)
                (blitzMode = 0);
            else
                (blitzMode = 1);
            serout('>');
            serout((blitzMode == 1) ? 'B' : 'N');
            serout('<');
        }
        clear_display();
        return (tempval);
    }
    if (address == 0xCFF3)
    {
        // simulated keyboard input 0=no key press, 1 = key press light LEDs

        threeHex[0][0] = (read6502(0x00FB) & 0xF0) >> 4;
        threeHex[0][1] = read6502(0x00FB) & 0xF;
        threeHex[1][0] = (read6502(0x00FA) & 0xF0) >> 4;
        threeHex[1][1] = read6502(0x00FA) & 0xF;
        threeHex[2][0] = (read6502(0x00F9) & 0xF0) >> 4;
        threeHex[2][1] = read6502(0x00F9) & 0xF;
        driveLEDs();

        return (getAkey() == 0 ? (uint8_t)0 : (uint8_t)1);
    }

    if (address >= 0xFFFA)
    {
        // 6502 reset and interrupt vectors. Reroute to top of ROM002.
        return (pgm_read_byte_near(monitor + address - 0xFC00));
    }

    return (0xE1);
}

void write6502(uint16_t address, uint8_t value)
{
    if (ramMain->inRange(address))
    {
        ramMain->write(address, value);
    }

#ifdef USE_EPROM
    if (address < 0x0800)
    {
        eepromwrite(address - 0x0400, value); // 0x0500-0x0900 is EEPROM for Arduino,
        return;
    }
#endif

    if (address < 0x1700)
    { // illegal access
        serout('%');
        serout('1'); // error code 1 - write in empty space
        return;
    }
    if (address < 0x1740)
    { // I/O 003
        serout('%');
        serout('3'); // trap code 3 - io3 access
        return;
    }

    if (riotIo002->inRange(address))
    {
        riotIo002->write(address, value);
    }

    if (ramRiot003->inRange(address))
    {
        ramRiot003->write(address, value);
    }

    if (ramRiot002->inRange(address))
    {
        ramRiot002->write(address, value);
    }

    if ((address >= 0x5000) && (address <= 0x6FDF))
    { // illegal write in fltpt65 ROM
        //	  printf("WARNING: WRITE TO ROM\n");
        serout('%');
        serout('a');
        return;
    }

    // Character out function for microchess only: write to display at $F001
    if (address == 0xCFF1)
    { // Character out for microchess only
        serout(value);
        return;
    }
    serout('%');
    serout('4'); // error code 4 - write to ROM
}
